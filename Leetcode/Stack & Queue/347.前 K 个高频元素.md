# 347. 前 K 个高频元素

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

## Answer

什么是优先级队列呢？

其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。

而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？

缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。

什么是堆呢？

堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。

所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。

本题我们就要使用优先级队列来对部分频率进行排序。

为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。

此时要思考一下，是使用小顶堆呢，还是大顶堆？

有的同学一想，题目要求前 K 个高频元素，那么果断用大顶堆啊。

那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。

而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？

所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。

```go
//方法一：小顶堆
func topKFrequent(nums []int, k int) []int {
    map_num:=map[int]int{}
    //记录每个元素出现的次数
    for _,item:=range nums{
        map_num[item]++
    }
    h:=&IHeap{}
    heap.Init(h)
    //所有元素入堆，堆的长度为k
    for key,value:=range map_num{
        heap.Push(h,[2]int{key,value})
        if h.Len()>k{
            heap.Pop(h)
        }
    }
    res:=make([]int,k)
    //按顺序返回堆中的元素
    for i:=0;i<k;i++{
        res[k-i-1]=heap.Pop(h).([2]int)[0]
    }
    return res
}

//构建小顶堆
type IHeap [][2]int

func (h IHeap) Len()int {
    return len(h)
}

func (h IHeap) Less (i,j int) bool {
    return h[i][1]<h[j][1]
}

func (h IHeap) Swap(i,j int) {
    h[i],h[j]=h[j],h[i]
}

func (h *IHeap) Push(x interface{}){
    *h=append(*h,x.([2]int))
}
func (h *IHeap) Pop() interface{}{
    old:=*h
    n:=len(old)
    x:=old[n-1]
    *h=old[0:n-1]
    return x
}
```

在 Go 语言中，`container/heap` 包提供了一个接口来实现任何类型的堆（最小堆或最大堆）。这个接口并不是一个显式定义的接口类型（像其他语言中的 interface 关键字定义的那样），而是一组必须由堆实现的方法。如果一个类型实现了这些方法，它就可以通过 `container/heap` 包的函数进行堆操作。

以下是 `container/heap` 包所要求的方法：

1. `Len() int`：返回堆中元素的数量。

2. `Less(i, j int) bool`：报告索引 `i` 的元素是否应该排在索引 `j` 的元素之前。这个方法决定了堆的性质（最小堆或最大堆）。对于最小堆，如果 `i` 元素小于 `j` 元素，则应返回 `true`。

3. `Swap(i, j int)`：交换索引 `i` 和 `j` 位置的元素。这个方法在重构堆的过程中被内部函数调用。

4. `Push(x interface{})`：将一个新元素 `x` 添加到堆中。这个方法应该把 `x` 添加到堆的末尾。

5. `Pop() interface{}`：从堆中移除并返回最后一个元素（注意，并不是最小或最大元素）。在堆的内部逻辑中，这通常是将堆顶元素与最后一个元素交换后弹出最后一个元素，以保持堆的属性。

这些方法使得 `container/heap` 包的内部函数，如 `Init()`, `Push()`, 和 `Pop()`, 能够正确地操作您的堆数据结构。您需要确保您的类型准确地实现了这些方法，以便标准库能够正确地管理堆的结构和操作。

在 Go 语言中，使用 `container/heap` 包实现堆时，堆的数据结构通常定义为一个满足 `sort.Interface` 的切片类型。这意味着您的堆类型应该是一个切片，其中的元素可以是任何您需要管理的类型。这些元素通常是结构体或者基本数据类型（如整数、字符串等），取决于您的具体需求。

以下是一个简单的堆的结构定义示例，其中我们使用一个整数切片来实现一个最小堆：

```go
type IntHeap []int
```

在这个例子中，`IntHeap` 是一个整数切片。为了使其能够作为堆使用，您需要为它实现 `container/heap` 包要求的几个方法：`Len()`, `Less()`, `Swap()`, `Push()` 和 `Pop()`。

如果您需要存储更复杂的数据结构，您可以定义一个包含所需字段的结构体类型，并使切片类型成为这个结构体的集合。例如，如果您想在堆中存储键值对，您的定义可能如下所示：

```go
type Item struct {
    Value    interface{} // 值的类型可以是任意类型
    Priority int         // 用于比较的优先级
}

type PriorityQueue []*Item
```

在这个例子中，`PriorityQueue` 是一个 `Item` 指针的切片。每个 `Item` 包含一个值和一个与之关联的优先级。在 `Less` 方法中，您将根据 `Priority` 字段来比较项目，以决定堆的顺序（最小堆或最大堆）。

总之，您的堆结构应该是一个切片，其中的元素类型根据您的具体需求而定。然后，您需要为这个类型实现 `container/heap` 包所需的方法，以便可以使用该包提供的堆操作。