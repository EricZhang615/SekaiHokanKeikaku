# 分布式系统要点大纲

## 分布式事务

### CAP 原理

CAP 定理描述的是一个分布式系统中，涉及共享数据问题时，以下三个特性最多只能同时满足其中两个。

- 一致性（Consistency）：代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的。基于证明严谨性的考虑，在学术的研究中一致性指的是强一致性（Strong Consistency）或者也叫做线性一致性（Linearizability）。
- 可用性（Availability）：代表系统不间断地提供服务的能力，理解可用性要先理解与其密切相关两个指标：可靠性（Reliability）和可维护性（Serviceability）。可靠性使用平均无故障时间（Mean Time Between Failure，MTBF）来度量；可维护性使用平均可修复时间（Mean Time To Repair，MTTR）来度量。可用性衡量系统可以正常使用的时间与总时间之比，其表征为：A=MTBF/（MTBF+MTTR），即可用性是由可靠性和可维护性计算得出的比例值，譬如 99.9999%可用，即代表平均年故障修复时间为 32 秒。
- 分区容错性（Partition tolerance）：代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力。

对一个分布式系统，因为必须要实现分区容错性，不能舍弃 P，CAP 其实是二选一（AP 和 CP 之间）而不是三选二的权衡。

- 放弃分区容忍性（CA without P）：意味着我们将假设节点之间通信永远是可靠（注意，笔者开篇的分布式八大缪误），永远可靠的通信在分布式系统中必定不成立，只要用到网络来共享数据，分区现象就会始终存在。没有 P，也谈不上是什么分布式系统。
- 放弃可用性（CP without A）：意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长。在现实中，选择放弃可用性的 CP 系统情况一般用于对数据质量要求很高的场合中。
- 放弃一致性（AP without C）：意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择，因为 P 是分布式网络的天然属性，你再不想要也无法丢弃；而 A 通常是建设分布式的目的，如果可用性随着节点数量增加反而降低的话，分布式系统也就失去了存在的价值，除非银行、证券这些涉及金钱交易的服务，宁可中断也不能出错，否则多数系统是不能容忍节点越多可用性反而越低。

### 分布式事务模型

#### 可靠事件队列

可靠事件队列关键在于可靠事件的投递和避免事件重复消费（幸运的是现在流行的消息中间件都实现了事件的持久化和最少一次 的投递模式，此外幂等性实现也有非常成熟的方案，所以这些要求也不再是问题）。

流程最核心、出错影响最大的服务优先处理，即：支付扣款 -> 仓库出库 -> 为用户增加积分，整个过程如图所示。

最大努力交付（Best-Effort Delivery）

![](https://www.thebyte.com.cn/assets/BASE-CawPKm5S.svg)

- 重复的操作决定着所有被消息服务器发送的消息操作都必须具备幂等性。此过程持续自动重复至双方通信恢复正常。
- 可靠消息队列方式只要第一步成功了，后续就没有失败回滚的概念，只许成功，不许失败。无法处理则不断轮询至可处理或人工介入

#### TCC（Try-Confirm-Cancel）

适合强隔离性的分布式事务

- Try 阶段：尝试执行阶段，完成所有业务可执行检查（预留必须业务资源，保障隔离性）。
- Confirm 阶段：如果所有分支的 Try 都成功了，则走到 Confirm 阶段。Confirm 真正执行业务，使用 Try 阶段预留的业务资源来完成处理。
- Cancel 阶段：如果所有分支的 Try 有一个失败了，则走到 Cancel 阶段，释放 Try 阶段预留的业务资源。

Confirm 和 Cancel 阶段只返回成功，不会返回失败，如果由于网络问题或者服务器临时故障，那么事务管理器会进行重试直至最终成功，所以这两个阶段的操作要求具备幂等性。

![](https://www.thebyte.com.cn/assets/TCC-DOZ3ns3d.svg)

1. Confirm 阶段异常，进行最大努力交付尝试。
2. Try 阶段异常，进入 Cancel 阶段。
3. Cancel 阶段异常，进行最大努力交付尝试。

#### SAGA

提升长时间事务运作效率的方法，大致的思路是把一个大事务分解成多个可交错运行的子事务集合，并在每个子事务中引入补偿操作。

SAGA 由两部分操作组成。

- 一部分是将大事务 T 拆分成若干小事务，命名为 T1，T2，Tn。每个子事务被应被视为原子行为，如果分布式事务 T 能够正常提交，那么它对数据的影响（最终一致性）就应该与连续按顺序成功提交子事务 Ti 等价。
- 另一部分是为每个子事务设计对应的补偿动作，命名为 C1，C2，Cn。Ti 与 Ci 满足以下条件：
  - Ti 与 Ci 具备幂等性。
  - Ti 与 Ci 满足交换律，即无论先执行 Ti 还是先执行 Ci，其效果都是一样的。
  - Ci 必须能成功提交，即不考虑 Ci 的失败回滚情况，如果出现失败持续重试直至成功或者被人工介入为止。

如果 T1 到 Tn 均执行成功，那么整个事务顺利完成，否则要根据下面两种恢复策略之一进行恢复。

- 正向操作（Forward Recovery）如果 Ti 提交失败，则一直对 Ti 进行重试，直至成功为止（最大努力交付）。这种恢复方式不需要进行补偿，适用于事务最终都要执行成功的情况，譬如订单服务中银行已经扣款，那么就一定要发货。
- 逆向回滚（Backward Recovery）如果 Ti 提交失败，则执行对应的补偿 Ci，直至恢复到 Ti 之前的状态，这里要求 Ci 必须成功（持续重试，最大努力交付）。

![](https://www.thebyte.com.cn/assets/saga-CQWt_tbw.svg)

#### 幂等性

使用全局唯一 ID 方案。

snowflake / snowflake + token

ABA 问题：尽管最终的值没有变化，但中间的状态改变被忽视了，可能会导致错误的行为。

通常可以使用乐观锁来解决, 即在数据中加一个版本号的概念，版本号不一致则产生异常处理

```sql
update order set price=80,version=version+1 where order=1 and version=1
```

## 分布式共识

