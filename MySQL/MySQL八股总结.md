# MySQL 八股

## 基础

### 执行一条 select 语句，期间发生了什么

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

#### 1. 连接器

建立TCP连接

长连接 / 短连接

管理连接
- 连接数上限
- 连接时间上限

校验身份

#### 2. 查询缓存

**server层缓存， 不是引擎的buffer pool**

MySQL 8.0 版本直接将查询缓存删掉了

#### 3. 解析 SQL

##### 解析器

1. 词法分析 得关键字
2. 语法分析
   - 只检查语法、构建语法树
   - 不会检查字段是否存在

#### 4. 执行 SQL

每条 SELECT 查询语句流程主要可以分为下面这三个阶段：

- prepare
  - 检查 SQL 查询语句中的表或者字段是否存在；
  - 将 select * 中的 * 符号，扩展为表上的所有列；
- optimize
  - 负责将 SQL 查询语句的执行方案确定下来（选择索引），选择查询成本最小的执行计划
- execute
  - 主键索引查询
    - 执行器调用引擎索引查询接口，传递条件要求定位
    - 引擎通过主键索引的 B+ 树定位记录
    - 执行器判断是否符合条件 不符合则跳过
    - 执行器查询的过程是一个 while 循环，所以还会再查一次；因为const类型，永远返回-1，退出循环
  - 全表扫描
    - 执行器调用引擎全扫描接口，要求读第一条记录
    - 执行器判断条件，是则直接发给客户端，否则跳过（读一条发一条）
    - 执行器查询的过程是一个 while 循环，所以还会再查一次；因为优化器选择访问类型为 all ，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，继续循环
    - 引擎向执行器返回读取完毕
    - 执行器收到查询完毕信息，退出循环
  - 索引下推 MySQL 5.6
    联合索引当遇到范围查询就会停止匹配
    - 执行器调用引擎接口定位满足条件的第一条二级索引记录
    - 引擎定位到二级索引后，先**不回表**，判断该索引中包含的列的条件是否成立。如果条件不成立，则直接跳过该二级索引。如果成立，则执行回表操作，将完成记录返回给执行器。
    - server层判断其他条件是否成绩
    - 循环

### MySQL 存储

文件 /var/lib/mysql/库名
db.opt table.frm（表结构） table.ibd（表数据）

#### 表空间文件的结构

表空间由段（segment）、区（extent）、页（page）、行（row）组成

InnoDB 的数据是按「页」为单位来读写的，默认每个页的大小为 16KB。

在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了

- 索引段：存放 B + 树的非叶子节点的区的集合；
- 数据段：存放 B + 树的叶子节点的区的集合；
- 回滚段：存放的是回滚数据的区的集合

#### InnoDB 行格式

Redundant、Compact、Dynamic、Compressed

- Redundant 弃用
- v 5.1 default Compact
- v 5.7 default Dynamic

#### Compact 行格式

##### 记录的额外信息

1. 变长字段长度列表
   - *变长字段的真实数据占用的字节数*会按照列的顺序逆序存放
     - 提高 CPU Cache 的命中率
   - NULL 是不会存放在行格式中记录的真实数据部分里
   - 「变长字段长度列表」只出现在数据表有变长字段的时候
2. NULL 值列表
   - 当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了
3. 记录头信息
   - delete_mask
   - next_record
   - record_type: 0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录

##### 记录的真实数据

隐藏字段
- row_id: 隐藏主键 不必需
- trx_id: 事务id 必须 6 byte
- roll_pointer: 上一个版本的指针 必需 7 byte

#### VARCHAR(n) 的最大取值

MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。

#### 行溢出

一个页存不了一条记录就会发生行溢出，多的数据就会存到另外的「溢出页」中。

## 索引

### 索引的分类

#### 按数据结构分类

B+Tree 索引、HASH 索引、Full-Text 索引

创建的主键索引和二级索引默认使用的是 B+Tree 索引。

- 如果有主键，主键作为聚簇索引的key
- 如果没有，选择 第一个 不包含 NULL 值 的 唯一列 作为key
- 都没有，自动生成一个隐式自增 id 列作为key

##### **为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？**

1. B+ vs B
    B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。

    另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找

2. B+ vs 二叉树
    高度更矮，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，I/O次数更少

3. B+ vs Hash
    Hash 不适合做范围查询

#### 按物理存储分类

聚簇索引（主键索引）、二级索引（辅助索引）

主键索引的 B+Tree 和二级索引的 B+Tree 区别：
- 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

#### 按字段特性分类

主键索引、唯一索引、普通索引、前缀索引

##### 主键索引

建立在主键字段上的索引，一张表最多只有一个主键索引，索引列的值不允许有空值。

```sql
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```

##### 唯一索引

建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。

```sql
CREATE TABLE table_name  (
  ....
  UNIQUE KEY(index_column_1,index_column_2,...) 
);

CREATE UNIQUE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```

##### 普通索引

建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。

```sql
CREATE TABLE table_name  (
  ....
  INDEX(index_column_1,index_column_2,...) 
);

CREATE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```

##### 前缀索引

对字符类型字段的前几个字符建立的索引

前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上

使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。

```sql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 

CREATE INDEX index_name
ON table_name(column_name(length)); 
```

#### 按字段个数分类

单列索引、联合索引（复合索引）
- 建立在单列上的索引称为单列索引，比如主键索引；
- 建立在多列上的索引称为联合索引；

通过将多个字段组合成一个索引，该索引就被称为联合索引

```sql
CREATE INDEX index_product_no_name 
ON product(product_no, name);
```

使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效

联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。

建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。

区分度就是某个字段 column 不同值的个数「除以」表的总行数

### 什么时候需要 / 不需要创建索引

什么时候适用索引？
- 字段有唯一性限制的，比如商品编码；
- 经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

什么时候不需要创建索引？
- WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
- 表数据太少的时候，不需要创建索引；
- 经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

### 优化索引的方法

#### 前缀索引优化

减小索引字段大小
- order by 就无法使用前缀索引；
- 无法把前缀索引用作覆盖索引；

#### 覆盖索引优化

不需要查询出包含整行记录的所有信息（减少回表）

#### 主键索引最好是自增的

避免页分裂 自增主键只用追加数据

#### 索引最好设置为 NOT NULL

- 索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂
- 额外占用物理空间

#### 防止索引失效

发生索引失效的情况

- 使用左或者左右模糊匹配，也就是 like %xx 或者 like %xx%；
- 在查询条件中对索引列做了计算、函数、类型转换操作；
  - 从 MySQL 8.0 开始，索引特性增加了函数索引
- 联合索引需要遵循最左匹配原则。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

### 从数据页角度看 B+ Tree

#### InnoDB 是如何存储数据页的

数据页中的记录按照「主键」顺序组成单向链表，数据页中有一个页目录，起到记录的索引作用。

![](https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png)

### COUNT()

count(*) = count(1) > count(主键字段) > count(字段)

#### COUNT 是什么

统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。

#### 执行过程

在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。