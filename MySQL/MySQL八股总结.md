# MySQL 八股

## 基础

### 执行一条 select 语句，期间发生了什么

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

#### 1. 连接器

建立TCP连接

长连接 / 短连接

管理连接
- 连接数上限
- 连接时间上限

校验身份

#### 2. 查询缓存

**server层缓存， 不是引擎的buffer pool**

MySQL 8.0 版本直接将查询缓存删掉了

#### 3. 解析 SQL

##### 解析器

1. 词法分析 得关键字
2. 语法分析
   - 只检查语法、构建语法树
   - 不会检查字段是否存在

#### 4. 执行 SQL

每条 SELECT 查询语句流程主要可以分为下面这三个阶段：

- prepare
  - 检查 SQL 查询语句中的表或者字段是否存在；
  - 将 select * 中的 * 符号，扩展为表上的所有列；
- optimize
  - 负责将 SQL 查询语句的执行方案确定下来（选择索引），选择查询成本最小的执行计划
- execute
  - 主键索引查询
    - 执行器调用引擎索引查询接口，传递条件要求定位
    - 引擎通过主键索引的 B+ 树定位记录
    - 执行器判断是否符合条件 不符合则跳过
    - 执行器查询的过程是一个 while 循环，所以还会再查一次；因为const类型，永远返回-1，退出循环
  - 全表扫描
    - 执行器调用引擎全扫描接口，要求读第一条记录
    - 执行器判断条件，是则直接发给客户端，否则跳过（读一条发一条）
    - 执行器查询的过程是一个 while 循环，所以还会再查一次；因为优化器选择访问类型为 all ，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，继续循环
    - 引擎向执行器返回读取完毕
    - 执行器收到查询完毕信息，退出循环
  - 索引下推 MySQL 5.6
    联合索引当遇到范围查询就会停止匹配
    - 执行器调用引擎接口定位满足条件的第一条二级索引记录
    - 引擎定位到二级索引后，先**不回表**，判断该索引中包含的列的条件是否成立。如果条件不成立，则直接跳过该二级索引。如果成立，则执行回表操作，将完成记录返回给执行器。
    - server层判断其他条件是否成绩
    - 循环

### MySQL 存储

文件 /var/lib/mysql/库名
db.opt table.frm（表结构） table.ibd（表数据）

#### 表空间文件的结构

表空间由段（segment）、区（extent）、页（page）、行（row）组成

InnoDB 的数据是按「页」为单位来读写的，默认每个页的大小为 16KB。

在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了

- 索引段：存放 B + 树的非叶子节点的区的集合；
- 数据段：存放 B + 树的叶子节点的区的集合；
- 回滚段：存放的是回滚数据的区的集合

#### InnoDB 行格式

Redundant、Compact、Dynamic、Compressed

- Redundant 弃用
- v 5.1 default Compact
- v 5.7 default Dynamic

#### Compact 行格式

##### 记录的额外信息

1. 变长字段长度列表
   - *变长字段的真实数据占用的字节数*会按照列的顺序逆序存放
     - 提高 CPU Cache 的命中率
   - NULL 是不会存放在行格式中记录的真实数据部分里
   - 「变长字段长度列表」只出现在数据表有变长字段的时候
2. NULL 值列表
   - 当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了
3. 记录头信息
   - delete_mask
   - next_record
   - record_type: 0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录

##### 记录的真实数据

隐藏字段
- row_id: 隐藏主键 不必需
- trx_id: 事务id 必须 6 byte
- roll_pointer: 上一个版本的指针 必需 7 byte

#### VARCHAR(n) 的最大取值

MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。

#### 行溢出

一个页存不了一条记录就会发生行溢出，多的数据就会存到另外的「溢出页」中。

## 索引

### 索引的分类

#### 按数据结构分类

B+Tree 索引、HASH 索引、Full-Text 索引

创建的主键索引和二级索引默认使用的是 B+Tree 索引。

- 如果有主键，主键作为聚簇索引的key
- 如果没有，选择 第一个 不包含 NULL 值 的 唯一列 作为key
- 都没有，自动生成一个隐式自增 id 列作为key

##### **为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？**

1. B+ vs B
    B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。

    另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找

2. B+ vs 二叉树
    高度更矮，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，I/O次数更少

3. B+ vs Hash
    Hash 不适合做范围查询

#### 按物理存储分类

聚簇索引（主键索引）、二级索引（辅助索引）

主键索引的 B+Tree 和二级索引的 B+Tree 区别：
- 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

#### 按字段特性分类

主键索引、唯一索引、普通索引、前缀索引

##### 主键索引

建立在主键字段上的索引，一张表最多只有一个主键索引，索引列的值不允许有空值。

```sql
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```

##### 唯一索引

建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。

```sql
CREATE TABLE table_name  (
  ....
  UNIQUE KEY(index_column_1,index_column_2,...) 
);

CREATE UNIQUE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```

##### 普通索引

建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。

```sql
CREATE TABLE table_name  (
  ....
  INDEX(index_column_1,index_column_2,...) 
);

CREATE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```

##### 前缀索引

对字符类型字段的前几个字符建立的索引

前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上

使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。

```sql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 

CREATE INDEX index_name
ON table_name(column_name(length)); 
```

#### 按字段个数分类

单列索引、联合索引（复合索引）
- 建立在单列上的索引称为单列索引，比如主键索引；
- 建立在多列上的索引称为联合索引；

通过将多个字段组合成一个索引，该索引就被称为联合索引

```sql
CREATE INDEX index_product_no_name 
ON product(product_no, name);
```

使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效

联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。

建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。

区分度就是某个字段 column 不同值的个数「除以」表的总行数

### 什么时候需要 / 不需要创建索引

什么时候适用索引？
- 字段有唯一性限制的，比如商品编码；
- 经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

什么时候不需要创建索引？
- WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
- 表数据太少的时候，不需要创建索引；
- 经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

### 优化索引的方法

#### 前缀索引优化

减小索引字段大小
- order by 就无法使用前缀索引；
- 无法把前缀索引用作覆盖索引；

#### 覆盖索引优化

不需要查询出包含整行记录的所有信息（减少回表）

#### 主键索引最好是自增的

避免页分裂 自增主键只用追加数据

#### 索引最好设置为 NOT NULL

- 索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂
- 额外占用物理空间

#### 防止索引失效

发生索引失效的情况

- 使用左或者左右模糊匹配，也就是 like %xx 或者 like %xx%；
- 在查询条件中对索引列做了计算、函数、类型转换操作；
  - 从 MySQL 8.0 开始，索引特性增加了函数索引
- 联合索引需要遵循最左匹配原则。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

### 从数据页角度看 B+ Tree

#### InnoDB 是如何存储数据页的

数据页中的记录按照「主键」顺序组成单向链表，数据页中有一个页目录，起到记录的索引作用。

![](https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png)

### COUNT()

count(*) = count(1) > count(主键字段) > count(字段)

#### COUNT 是什么

统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。

#### 执行过程

在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。

## 事务

### ACID

- 原子性：一个事务中的所有操作，要么全部完成，要么全部不完成
- 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态
- 隔离性：允许并发多个事务。每个事务都有一个完整的数据空间，对其他并发事务是隔离的
- 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

InnoDB 如何保证 ACID
- 持久性：redo log
- 原子性：undo log
- 隔离性：MVCC
- 一致性：A + I + D

### 隔离性 / 并行事务

#### 脏读

一个事务「读到」了另一个「未提交事务修改过的数据」

#### 不可重复读

一个事务内多次读取同一个数据，出现前后两次读到的数据不一样

#### 幻读

在一个事务内多次查询某个符合查询条件的**记录数量**，出现前后两次查询到的记录数量不一样

### 事务隔离级别

严重程度：脏读 > 不可重复读 > 幻读

四种隔离级别，隔离级别越高，性能效率就越低
- 读未提交：指一个事务还没提交时，它做的变更就能被其他事务看到
- 读提交：指一个事务提交之后，它做的变更才能被其他事务看到
- 可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**
- 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

隔离水平：串行化 > 可重复读 > 读提交 > 读未提交

可能发生：null > 幻读 > 幻读 不可重复读 > 幻读 不可重复读 脏读

MySQL InnoDB 引擎的默认隔离级别「可重复读」，很大程度上避免幻读现象
- 针对快照读（select）：MVCC 自然保证旧版本的会被忽略
- 针对当前读（select ... for update）：
  - 当前读时不依赖 Read View 直接访问最新数据版本
  - 当前事务生成next-key lock（记录锁+间隙锁）冲突事务生成插入意向锁，进入等待状态

### Read View

Read View 字段，创建 Read View 时
- m_ids ：当前数据库中「活跃事务」的事务 id 列表；“活跃事务”指启动了但还没提交的事务。
- min_trx_id ：当前数据库中「活跃事务」中事务 id 最小的事务，即 m_ids 的最小值。
- max_trx_id ：当前数据库中应该给下一个事务的 id 值，即全局事务中最大的事务 id 值 + 1；
- creator_trx_id ：创建该 Read View 的事务的事务 id。

InnoDB 隐藏列
- trx_id : 一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id
- roll_pointer : 对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，roll_pointer 指向每一个旧版本记录

版本链 **MVCC**
- `trx_id < min_trx_id`
  - 当前版本记录是当前Read View前已提交事务的
  - **可见**
- `trx_id >= max_trx_id`
  - 当前版本记录是当前Read View后创建的事务的
  - **不可见**
- `min_trx_id <= trx_id < max_trx_id`
  - `trx_id in m_ids`
    - 当前版本记录的活跃事务依然活跃着 还未提交
    - **不可见**
  - `trx_id not in m_ids`
    - 当前版本记录的活跃事务已经提交
    - **可见**

### 可重复读

可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。

### 读提交

读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。

### 读未提交

不创建 Read View

## 锁

全局锁、表级锁、行锁

### 全局锁

```sql
flush tables with read lock
```
执行后，整个数据库就处于只读状态了

主要应用于做全库逻辑备份

开启前启动**可重复读**事务，备份期间业务依然可以操作数据

### 表级锁

表锁、元数据锁（MDL）、意向锁、AUTO-INC 锁；

#### 表锁

表级别的共享锁，也就是读锁；
```sql
lock tables t_student read;
```
表级别的独占锁，也就是写锁；
只有发出锁定命令的会话可以对该表进行写操作，其他会话不能读取或写入该表
```sql
lock tables t_stuent write;
```

#### 元数据锁 MDL

MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更

申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

#### 意向锁

当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。

意向锁的目的是为了快速判断表里是否有记录被加锁。
- 有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。

#### AUTO-INC 锁

在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。

MySQL 5.1.22 : 轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。

### 行级锁

Record Lock, Gap Lock, Next-Key Lock

#### Record Lock

Record Lock 称为记录锁，锁住的是一条记录。

有 S 锁和 X 锁：SS 兼容，SX互斥，XX互斥

#### Gap Lock

间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象

间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。

#### Next-Key Lock

临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

#### 插入意向锁

表明有事务想在某个区间插入新记录，但是现在处于等待状态。

### 什么时候会加行级锁

update delete 都会加 X 锁

加锁的对象是索引，加锁的基本单位是 next-key lock；在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁。

## 日志

- undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。
- redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；
- binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制；

### undo log

在**插入**一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录**删掉**就好了；
在**删除**一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录**插入**到表中就好了；
在**更新**一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列**更新为旧值**就好了。

1. 实现事务回滚 保证原子性
2. 实现 MVCC

### Buffer Pool

也是按最小操作单元 页 16KB

Buffer Pool 缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等

### redo log

WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。

redo log 是物理日志，记录了某个数据页做了什么修改，在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。

所以 undo log 也会被记录

事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务

- 实现事务的持久性，让 MySQL 有 crash-safe 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；
- 将写操作从「随机写」变成了「顺序写」

#### redo log 刷盘

redo log 也有 redo log buffer

主要有下面几个时机：
- MySQL 正常关闭时；
- 当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；
- InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。
- 每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制）。

redo log group 循环写 buffer pool 刷盘后删除对应的redo log

### bin log

与redo log区别
1. 适用对象不同
   - binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；
   - redo log 是 Innodb 存储引擎实现的日志；
2. 文件格式不同
   - redo log 是物理日志
   - binlog 记录逻辑操作
3. 写入方式不同
   - binlog 追加写 保存全量日志
   - redo log 循环写 保存脏页日志
4. 用途不同
   - binlog 备份恢复 主从复制
   - redo log crash-safe

#### 主从复制

MySQL 集群的主从复制过程梳理成 3 个阶段：

- 写入 Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。
- 同步 Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。
- 回放 Binlog：回放 binlog，并更新存储引擎中的数据。

MySQL 主从复制模型：

- 同步复制
- 异步复制（默认）
- 半同步复制 v5.7 只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端

#### binlog 刷盘

事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。

### 两阶段提交

在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。

两阶段提交分为两个过程：准备阶段、提交阶段

#### 两阶段提交过程

内部 XA 事务
- 准备阶段：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）
- 把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；
- 异常重启后，对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID。所以说，两阶段提交是以 binlog 写成功为事务提交成功的标识

#### 两阶段提交问题

1. 磁盘 I/O 次数高：“双1”配置 两次fsync
2. 锁竞争激烈：多事务时加锁保证日志提交顺序一致

组提交将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数；同时只给队列加锁，减小锁的粒度

## 内存

### Buffer Pool

Free 链表：空闲页
Flush 链表：脏页
LRU 链表：干净页和脏页

#### LRU 优化

问题：
- 预读失效
- Buffer Pool 污染

分为young区域和old区域

预读的页只进入old区域，真正被访问后加入young的头部

在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：
- 如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该缓存页就不会被从 old 区域移动到 young 区域的头部；
- 如果后续的访问时间与第一次访问的时间不在某个时间间隔内，那么该缓存页移动到 young 区域的头部；
这个间隔时间是由 innodb_old_blocks_time 控制的，默认是 1000 ms。

只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部，这样就解决了 Buffer Pool 污染的问题 